 // getData(): Observable<
  //   {
  //     question: string;
  //     answer: string;
  //     choices: string[];
  //   }[]
  // > {
  //   let jsonUrl = 'assets/json/riddles.json';

  //   return this.httpClient.get<
  //     {
  //       question: string;
  //       answer: string;
  //       choices: string[];
  //     }[]
  //   >(jsonUrl);
  // }

  // async addQuestionBatch(
  //   type: Questions['type'],
  //   data: { question: string; answer: string; choices: string[] }[]
  // ) {
  //   const lastDocQuery = query(
  //     collection(this.firestore, QUESTION_COLLECTION).withConverter(
  //       questionConverter
  //     ),
  //     orderBy('id', 'desc'),
  //     limit(1)
  //   );

  //   const lastDocSnapshot = await getDocs(lastDocQuery);
  //   const lastDoc = lastDocSnapshot.docs[0];
  //   const prevCount = lastDoc ? lastDoc.data().id : 0;

  //   const batch = writeBatch(this.firestore);
  //   const questions: Questions[] = data.map((e, index) => {
  //     return {
  //       id: prevCount + index + 1,
  //       question: e.question,
  //       answer: e.answer,
  //       choices: e.choices,
  //       type: type,
  //       createdAt: new Date(),
  //       updatedAt: new Date(),
  //     };
  //   });

  //   questions.forEach((question) => {
  //     batch.set(
  //       doc(this.firestore, QUESTION_COLLECTION, question.id.toString()),
  //       question
  //     );
  //   });

  //   return batch.commit();
  // }

  // getNextQuestion(limits: number = 10) {
  //   const q = query(
  //     collection(this.firestore, QUESTION_COLLECTION).withConverter(
  //       questionConverter
  //     ),
  //     orderBy('id', 'asc'),

  //     limit(limits)
  //   );
  //   return getDocs(q).then((snapshot) =>
  //     snapshot.docs.map((doc) => doc.data() as Questions)
  //   );
  // }

  loadMoreQuestion(start: number, limits: number = 10) {
    const q = query(
      collection(this.firestore, QUESTION_COLLECTION).withConverter(
        questionConverter
      ),
      orderBy('id', 'asc'),
      startAfter(start),
      limit(limits)
    );
    return getDocs(q).then((snapshot) =>
      snapshot.docs.map((doc) => doc.data() as Questions)
    );
  }
  getPreviousQuestion(end: number, limits: number = 10) {
    const q = query(
      collection(this.firestore, QUESTION_COLLECTION).withConverter(
        questionConverter
      ),
      orderBy('id', 'asc'),
      endBefore(end),
      limit(limits)
    );
    return getDocs(q).then((snapshot) =>
      snapshot.docs.map((doc) => doc.data() as Questions)
    );
  }